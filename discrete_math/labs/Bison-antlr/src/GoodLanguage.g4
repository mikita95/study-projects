grammar GoodLanguage;

program: (method | statement)+ ;
statement: (assignment | forStructure | whileStructure | read | write | function | variables | ifStructure | swap | returnStructure) SEMICOLON* ;
assignment: lvalueblock ASSIGN rvalueblock ;
variables: VAR (lvalueblock | assignment) ;
lvalueblock: lvalue (COMMA lvalue)* ;
lvalue: NAME ;
rvalue: ((PLUS | MINUS))? (atom ((MULT | DIV | PR) atom )*) ((PLUS | MINUS) (atom ((MULT | DIV | PR) atom )*))*;
atom: NUMBER | lvalue | function | LPAREN rvalue RPAREN | sqrt;
rvalueblock: rvalue (COMMA rvalue)* ;
function: NAME LPAREN rvalueblock RPAREN ;
read: RD lvalueblock ;
write: (WR | WRL) writable (COMMA writable)*;
writable: rvalue | '"' line '"' ;
line: ('.'|':'|~('"'|'\n'|'\r'))* ;
body: statement | LCURLY (statement)* RCURLY ;
forStructure: FOR LPAREN forBlock RPAREN body ;
forAtom: lvalue ':' rvalue '..' rvalue ;
forBlock: forAtom (COMMA forAtom)* ;
booleanExpression : booleanTerm ((AND | OR) booleanTerm)* ;
booleanTerm   : NOT? booleanAtom ;
booleanAtom   : booleanValue | compare | rvalue | LPAREN booleanExpression RPAREN ;
compare : rvalue (L | G | LE | GE | E | NE) rvalue ;
whileStructure: WHILE LPAREN booleanExpression RPAREN body ;
ifStructure: IF LPAREN booleanExpression RPAREN body (ELSE body)? ;
returnStructure: RETURN rvalue SEMICOLON* ;
booleanValue: 'false' | 'true' ;
swap: SWAP lvalue COMMA lvalue;
sqrt: SQRT '(' lvalue ')';
method: DEF NAME LPAREN lvalueblock? RPAREN body;

DEF: 'def' ;
FOR: 'for' ;
WHILE: 'while' ;
ELSE: 'else' ;
RETURN: 'return' ;
SWAP: 'swap' ;
SQRT: 'sqrt' ;
IF: 'if' ;
OR  : '|' ;
AND : '&' ;
NOT : '!' ;
L  : '<' ;
LE  : '<=' ;
G  : '>' ;
GE: '>=' ;
E : '==' ;
NE : '!=' | '<>';
LCURLY: '{' ;
RCURLY: '}' ;
RD: '>>' ;
WR: '<<' ;
WRL: '<<<' ;
VAR: 'var' ;
PLUS: '+' ;
MINUS: '-' ;
MULT: '*' ;
DIV: '/' ;
PR: '%';
NUMBER: [0-9]+ ;
LPAREN: '(' ;
RPAREN: ')' ;
NAME: ([A-Z]|[a-z])+ ;
COMMA: ',' ;
ASSIGN: '=' ;
SEMICOLON: ';' ;
WS: [ \t]+ -> skip;
NWR: '\r'? '\n' -> skip;
NL: '\n' -> skip ;